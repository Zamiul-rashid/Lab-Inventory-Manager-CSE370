# sql_queries_reference.py - SQL Queries Generated by Django ORM

"""
This file documents the SQL queries that Django generates for common operations
in the Lab Inventory Manager project. This is helpful for understanding
database performance and debugging.
"""

# ==============================================================================
# MODEL FIELD TYPES AND THEIR SQL EQUIVALENTS
# ==============================================================================

"""
Django Model Field -> MySQL/PostgreSQL SQL Type

CharField(max_length=50) -> VARCHAR(50)
TextField() -> TEXT
EmailField() -> VARCHAR(254) (with email validation at Django level)
DateTimeField() -> DATETIME (MySQL) / TIMESTAMP (PostgreSQL)
DateField() -> DATE
BooleanField() -> BOOLEAN / TINYINT(1)
PositiveIntegerField() -> INT UNSIGNED (MySQL) / INTEGER CHECK (value >= 0) (PostgreSQL)
AutoField() -> INT AUTO_INCREMENT PRIMARY KEY (MySQL) / SERIAL PRIMARY KEY (PostgreSQL)
ForeignKey() -> INT + FOREIGN KEY constraint

Field Options:
- null=True -> NULL
- blank=True -> (Django form validation, no SQL effect)
- unique=True -> UNIQUE constraint
- default=value -> DEFAULT value
- db_index=True -> CREATE INDEX
"""

# ==============================================================================
# TABLE CREATION SQL (from Django migrations)
# ==============================================================================

USER_TABLE_SQL = """
-- User model (extends AbstractUser)
CREATE TABLE `inventory_user` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `password` varchar(128) NOT NULL,
    `last_login` datetime(6) DEFAULT NULL,
    `is_superuser` tinyint(1) NOT NULL,
    `username` varchar(150) NOT NULL UNIQUE,
    `first_name` varchar(150) NOT NULL,
    `last_name` varchar(150) NOT NULL,
    `email` varchar(254) NOT NULL UNIQUE,
    `is_staff` tinyint(1) NOT NULL,
    `is_active` tinyint(1) NOT NULL,
    `date_joined` datetime(6) NOT NULL,
    `user_id` varchar(5) UNIQUE DEFAULT NULL,
    `firstname` varchar(50) NOT NULL,
    `lastname` varchar(50) NOT NULL,
    `date_created` datetime(6) NOT NULL,
    `role` varchar(20) NOT NULL DEFAULT 'regular_user',
    PRIMARY KEY (`id`),
    UNIQUE KEY `username` (`username`),
    UNIQUE KEY `email` (`email`),
    UNIQUE KEY `user_id` (`user_id`)
);
"""

PRODUCT_TABLE_SQL = """
-- Product model
CREATE TABLE `inventory_product` (
    `product_id` int(11) NOT NULL AUTO_INCREMENT,
    `name` varchar(200) NOT NULL,
    `description` longtext NOT NULL,
    `category` varchar(100) NOT NULL,
    `brand` varchar(100) NOT NULL,
    `quantity_available` int(10) unsigned NOT NULL,
    `current_location` varchar(200) NOT NULL,
    `status` varchar(20) NOT NULL,
    `notes` longtext NOT NULL,
    `created_at` datetime(6) NOT NULL,
    `created_by_id` bigint(20) DEFAULT NULL,
    PRIMARY KEY (`product_id`),
    KEY `created_by_id` (`created_by_id`),
    KEY `inventory_product_name_idx` (`name`),
    KEY `inventory_product_category_idx` (`category`),
    KEY `inventory_product_status_idx` (`status`),
    CONSTRAINT `inventory_product_created_by_id_fk` 
        FOREIGN KEY (`created_by_id`) 
        REFERENCES `inventory_user` (`id`) 
        ON DELETE SET NULL
);
"""

BORROW_TABLE_SQL = """
-- Borrow model
CREATE TABLE `inventory_borrow` (
    `borrow_id` int(11) NOT NULL AUTO_INCREMENT,
    `borrow_date` datetime(6) NOT NULL,
    `expected_return_date` date NOT NULL,
    `actual_return_date` date DEFAULT NULL,
    `status` varchar(20) NOT NULL,
    `notes` longtext NOT NULL,
    `created_at` datetime(6) NOT NULL,
    `added_by_id` bigint(20) DEFAULT NULL,
    `product_id` int(11) NOT NULL,
    `user_id` bigint(20) NOT NULL,
    PRIMARY KEY (`borrow_id`),
    KEY `added_by_id` (`added_by_id`),
    KEY `product_id` (`product_id`),
    KEY `user_id` (`user_id`),
    KEY `inventory_borrow_status_idx` (`status`),
    KEY `inventory_borrow_date_idx` (`borrow_date`),
    CONSTRAINT `inventory_borrow_added_by_id_fk` 
        FOREIGN KEY (`added_by_id`) 
        REFERENCES `inventory_user` (`id`) 
        ON DELETE SET NULL,
    CONSTRAINT `inventory_borrow_product_id_fk` 
        FOREIGN KEY (`product_id`) 
        REFERENCES `inventory_product` (`product_id`) 
        ON DELETE CASCADE,
    CONSTRAINT `inventory_borrow_user_id_fk` 
        FOREIGN KEY (`user_id`) 
        REFERENCES `inventory_user` (`id`) 
        ON DELETE CASCADE
);
"""

# ==============================================================================
# COMMON DJANGO ORM QUERIES AND THEIR SQL
# ==============================================================================

# 1. Basic Queries
"""
# Django ORM
Product.objects.all()

# Generated SQL:
SELECT `product_id`, `name`, `description`, `category`, `brand`, 
       `quantity_available`, `current_location`, `status`, `notes`, 
       `created_at`, `created_by_id` 
FROM `inventory_product`;
"""

"""
# Django ORM
Product.objects.get(pk=1)

# Generated SQL:
SELECT `product_id`, `name`, `description`, `category`, `brand`, 
       `quantity_available`, `current_location`, `status`, `notes`, 
       `created_at`, `created_by_id` 
FROM `inventory_product` 
WHERE `inventory_product`.`product_id` = 1 
LIMIT 21;
"""

"""
# Django ORM
Product.objects.filter(status='available')

# Generated SQL:
SELECT `product_id`, `name`, `description`, `category`, `brand`, 
       `quantity_available`, `current_location`, `status`, `notes`, 
       `created_at`, `created_by_id` 
FROM `inventory_product` 
WHERE `inventory_product`.`status` = 'available';
"""

# 2. Search Queries
"""
# Django ORM
Product.objects.filter(
    Q(name__icontains='microscope') |
    Q(description__icontains='microscope') |
    Q(category__icontains='microscope')
)

# Generated SQL:
SELECT `product_id`, `name`, `description`, `category`, `brand`, 
       `quantity_available`, `current_location`, `status`, `notes`, 
       `created_at`, `created_by_id` 
FROM `inventory_product` 
WHERE (
    `inventory_product`.`name` LIKE '%microscope%' OR 
    `inventory_product`.`description` LIKE '%microscope%' OR 
    `inventory_product`.`category` LIKE '%microscope%'
);
"""

# 3. Relationship Queries (JOIN operations)
"""
# Django ORM (N+1 problem - BAD)
for borrow in Borrow.objects.all():
    print(borrow.user.username)
    print(borrow.product.name)

# Generated SQL (multiple queries):
SELECT * FROM `inventory_borrow`;
-- Then for each borrow:
SELECT * FROM `inventory_user` WHERE `id` = ?;
SELECT * FROM `inventory_product` WHERE `product_id` = ?;
"""

"""
# Django ORM (Optimized with select_related - GOOD)
Borrow.objects.select_related('user', 'product').all()

# Generated SQL (single query with JOINs):
SELECT `inventory_borrow`.`borrow_id`, `inventory_borrow`.`borrow_date`,
       `inventory_borrow`.`expected_return_date`, `inventory_borrow`.`actual_return_date`,
       `inventory_borrow`.`status`, `inventory_borrow`.`notes`,
       `inventory_borrow`.`created_at`, `inventory_borrow`.`added_by_id`,
       `inventory_borrow`.`product_id`, `inventory_borrow`.`user_id`,
       `inventory_user`.`id`, `inventory_user`.`username`, `inventory_user`.`email`,
       `inventory_product`.`product_id`, `inventory_product`.`name`, `inventory_product`.`category`
FROM `inventory_borrow` 
INNER JOIN `inventory_user` ON (`inventory_borrow`.`user_id` = `inventory_user`.`id`)
INNER JOIN `inventory_product` ON (`inventory_borrow`.`product_id` = `inventory_product`.`product_id`);
"""

# 4. Aggregation Queries
"""
# Django ORM
Product.objects.aggregate(
    total_products=Count('pk'),
    available_count=Count('pk', filter=Q(status='available'))
)

# Generated SQL:
SELECT COUNT(`inventory_product`.`product_id`) AS `total_products`,
       COUNT(CASE WHEN `inventory_product`.`status` = 'available' THEN `inventory_product`.`product_id` ELSE NULL END) AS `available_count`
FROM `inventory_product`;
"""

"""
# Django ORM
Product.objects.values('category').annotate(count=Count('pk')).order_by('-count')

# Generated SQL:
SELECT `inventory_product`.`category`, COUNT(`inventory_product`.`product_id`) as `count`
FROM `inventory_product` 
GROUP BY `inventory_product`.`category` 
ORDER BY `count` DESC;
"""

# 5. Complex Filtering
"""
# Django ORM
Borrow.objects.filter(
    status='active',
    expected_return_date__lt=timezone.now().date()
)

# Generated SQL:
SELECT `borrow_id`, `borrow_date`, `expected_return_date`, `actual_return_date`,
       `status`, `notes`, `created_at`, `added_by_id`, `product_id`, `user_id`
FROM `inventory_borrow` 
WHERE (`inventory_borrow`.`status` = 'active' AND 
       `inventory_borrow`.`expected_return_date` < '2025-09-01');
"""

# 6. Ordering and Limiting
"""
# Django ORM
Product.objects.order_by('-created_at')[:10]

# Generated SQL:
SELECT `product_id`, `name`, `description`, `category`, `brand`, 
       `quantity_available`, `current_location`, `status`, `notes`, 
       `created_at`, `created_by_id` 
FROM `inventory_product` 
ORDER BY `inventory_product`.`created_at` DESC 
LIMIT 10;
"""

# 7. Update Operations
"""
# Django ORM
Product.objects.filter(status='borrowed').update(quantity_available=F('quantity_available') - 1)

# Generated SQL:
UPDATE `inventory_product` 
SET `quantity_available` = (`inventory_product`.`quantity_available` - 1) 
WHERE `inventory_product`.`status` = 'borrowed';
"""

# 8. Bulk Operations
"""
# Django ORM
products = [
    Product(name='Product 1', category='Category A'),
    Product(name='Product 2', category='Category B'),
]
Product.objects.bulk_create(products)

# Generated SQL:
INSERT INTO `inventory_product` (`name`, `description`, `category`, `brand`, 
                                `quantity_available`, `current_location`, `status`, 
                                `notes`, `created_at`, `created_by_id`) 
VALUES ('Product 1', '', 'Category A', '', 1, 'Lab Storage', 'available', '', NOW(), NULL),
       ('Product 2', '', 'Category B', '', 1, 'Lab Storage', 'available', '', NOW(), NULL);
"""

# 9. Complex Dashboard Query Example
"""
# Django ORM (from your dashboard view)
available_items = Product.objects.filter(status='available').count()
my_borrowed = Borrow.objects.filter(user=user, status='active').count()

# Generated SQL (2 separate queries):
SELECT COUNT(*) AS `__count` FROM `inventory_product` WHERE `inventory_product`.`status` = 'available';
SELECT COUNT(*) AS `__count` FROM `inventory_borrow` WHERE (`inventory_borrow`.`user_id` = 1 AND `inventory_borrow`.`status` = 'active');

# Optimized version (single query):
stats = Product.objects.aggregate(
    available_count=Count('pk', filter=Q(status='available')),
    total_categories=Count('category', distinct=True)
)

# Generated SQL:
SELECT COUNT(CASE WHEN `inventory_product`.`status` = 'available' THEN `inventory_product`.`product_id` ELSE NULL END) AS `available_count`,
       COUNT(DISTINCT `inventory_product`.`category`) AS `total_categories`
FROM `inventory_product`;
"""

# 10. Raw SQL (when ORM isn't sufficient)
"""
# Django ORM
products = Product.objects.raw('''
    SELECT p.*, 
           COUNT(b.borrow_id) as borrow_count,
           AVG(DATEDIFF(b.actual_return_date, b.borrow_date)) as avg_borrow_days
    FROM inventory_product p
    LEFT JOIN inventory_borrow b ON p.product_id = b.product_id AND b.status = 'returned'
    WHERE p.created_at >= %s
    GROUP BY p.product_id
    ORDER BY borrow_count DESC
''', [datetime.now() - timedelta(days=365)])
"""

# ==============================================================================
# DATABASE INDEXES FOR PERFORMANCE
# ==============================================================================

"""
-- Indexes that should be created for optimal performance:

-- For Product search functionality
CREATE INDEX idx_product_name ON inventory_product(name);
CREATE INDEX idx_product_category ON inventory_product(category);
CREATE INDEX idx_product_status ON inventory_product(status);
CREATE INDEX idx_product_name_category ON inventory_product(name, category);

-- For Borrow queries
CREATE INDEX idx_borrow_user_status ON inventory_borrow(user_id, status);
CREATE INDEX idx_borrow_status_date ON inventory_borrow(status, expected_return_date);
CREATE INDEX idx_borrow_product_status ON inventory_borrow(product_id, status);

-- For date-based queries
CREATE INDEX idx_product_created_at ON inventory_product(created_at);
CREATE INDEX idx_borrow_created_at ON inventory_borrow(created_at);
CREATE INDEX idx_user_date_created ON inventory_user(date_created);

-- Composite indexes for common query patterns
CREATE INDEX idx_product_category_status ON inventory_product(category, status);
CREATE INDEX idx_borrow_user_status_date ON inventory_borrow(user_id, status, expected_return_date);
"""

# ==============================================================================
# PERFORMANCE TIPS
# ==============================================================================

"""
1. Use select_related() for foreign key relationships to avoid N+1 queries
2. Use prefetch_related() for reverse foreign keys and many-to-many relationships
3. Use only() to limit fields when you don't need all columns
4. Use iterator() for large datasets to avoid loading everything into memory
5. Use bulk_create(), bulk_update() for mass operations
6. Add database indexes for frequently queried fields
7. Use database functions instead of Python logic when possible
8. Monitor slow queries and optimize them

Example of optimized query:
# Bad (N+1 queries):
for product in Product.objects.all():
    print(f"{product.name} created by {product.created_by.username}")

# Good (single query):
for product in Product.objects.select_related('created_by'):
    print(f"{product.name} created by {product.created_by.username}")
"""

# ==============================================================================
# DJANGO DEBUG TOOLBAR QUERIES
# ==============================================================================

"""
To see actual SQL queries in development, add django-debug-toolbar:

1. pip install django-debug-toolbar
2. Add to INSTALLED_APPS: 'debug_toolbar'
3. Add to MIDDLEWARE: 'debug_toolbar.middleware.DebugToolbarMiddleware'
4. Add to INTERNAL_IPS: ['127.0.0.1']
5. Include in URLs: path('__debug__/', include(debug_toolbar.urls))

This will show you:
- Number of SQL queries per page
- Query execution time
- Duplicate queries
- Slow queries
- Query explanations
"""
